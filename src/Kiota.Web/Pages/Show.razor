@page "/show"
@using Kiota.Builder
@using Kiota.Builder.SearchProviders
@using Kiota.Builder.Configuration
@using System.Linq
@using System.Text;
@inject ILoggerFactory LoggerFactory
@inject NavigationManager navManager
@using System.Globalization
@using Microsoft.Extensions.Localization
@inject IStringLocalizer<Show> Loc

<PageTitle>@Loc["PageTitle"]</PageTitle>

<h1>@Loc["Show"]</h1>

<div>
    <div class="form-group">
        <div class="form-row">
            <div class="form-group col-xs-12 col-sm-12 col-md-12 col-lg-6">
                <label for="term">@Loc["SearchKey"]</label>
                <input id="term" type="text" @bind="SearchTerm" class="form-control" />
            </div>
        </div>
        <div class="form-row">
            <div class="form-group col-xs-12 col-sm-12 col-md-12 col-lg-6">
                <label for="version">@Loc["Version"]</label>
                <input id="version" type="text" @bind="Version" class="form-control" />
            </div>
        </div>
    </div>
    <div class="form-group">
        <div class="form-row">
            <div class="form-group col-xs-12 col-sm-12 col-md-12 col-lg-6">
                <label for="descriptionUrl">@Loc["DescriptionUrl"]</label>
                <input id="descriptionUrl" type="text" @bind="DescriptionUrl" class="form-control" />
            </div>
        </div>
    </div>
    <div class="form-group">
        <div class="form-row">
            <div class="form-group col-xs-12 col-sm-12 col-md-12 col-lg-6">
                <label for="includePatterns">@Loc["IncludePatterns"]</label>
                <textarea id="includePatterns" type="text" @bind="IncludePatterns" class="form-control" rows="5"></textarea>
            </div>
        </div>
        <div class="form-row">
            <div class="form-group col-xs-12 col-sm-12 col-md-12 col-lg-6">
                <label for="excludePatterns">@Loc["ExcludePatterns"]</label>
                <textarea id="excludePatterns" type="text" @bind="ExcludePatterns" class="form-control" rows="5"></textarea>
            </div>
        </div>
    </div>
    <button @onclick="ShowDescription" class="btn btn-primary">@Loc["ShowButton"]</button>
    <button @onclick="GoToGenerate" class="btn btn-secondary" disabled="@(string.IsNullOrEmpty(DescriptionUrl))">@Loc["GoToGenerate"]</button>
</div>

@if(!string.IsNullOrEmpty(Tree)) {
    <div>
        <h2>@Loc["ApiPaths"]</h2>
        <pre>@Tree</pre>
    </div>
}

@code {
    [Parameter]
    [SupplyParameterFromQuery(Name = "k")]
    public string? SearchTermFromQuery { get; set; }
    public string? SearchTerm { get; set; }
    [Parameter]
    [SupplyParameterFromQuery(Name = "v")]
    public string? VersionFromQuery { get; set; }
    public string? Version { get; set; }
    private string? DescriptionUrl { get; set; }
    private IDictionary<string, SearchResult> SearchResults = new Dictionary<string, SearchResult>();
    private string? IncludePatterns { get; set; }
    private string? ExcludePatterns { get; set; }
    private string? Tree { get; set; }
    protected override async Task OnParametersSetAsync() {
        if(!string.IsNullOrEmpty(SearchTermFromQuery))
            SearchTerm = SearchTermFromQuery;
        if(!string.IsNullOrEmpty(VersionFromQuery))
            Version = VersionFromQuery;
        if (!string.IsNullOrEmpty(SearchTerm) && !string.IsNullOrEmpty(Version) && string.IsNullOrEmpty(DescriptionUrl)) {
            var logger = LoggerFactory.CreateLogger<KiotaSearcher>();
            var searchConfig = new SearchConfiguration() {
                SearchTerm = SearchTerm,
                Version = Version,
            };
            var searchResults = await new KiotaSearcher(logger, searchConfig).SearchAsync(ComponentDetached);
            if(searchResults.Any())
                DescriptionUrl = searchResults.Values.First().DescriptionUrl.ToString();
        }
        await base.OnParametersSetAsync();
    }
    private void GoToGenerate() {
        if(!string.IsNullOrEmpty(DescriptionUrl))
        {
            var includeFilters = string.IsNullOrEmpty(IncludePatterns) ? string.Empty : string.Join(",", IncludePatterns
                                .Split(new [] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
                                .Select(static x => x.Trim()));
            var excludeFilters = string.IsNullOrEmpty(ExcludePatterns) ? string.Empty : string.Join(",", ExcludePatterns
                                .Split(new [] { Environment.NewLine }, StringSplitOptions.RemoveEmptyEntries)
                                .Select(static x => x.Trim()));
            navManager.NavigateTo($"/generate?d={DescriptionUrl}&i={includeFilters}&e={excludeFilters}");
        }
    }
    private async Task ShowDescription() {
        Tree = string.Empty;
        if (string.IsNullOrEmpty(DescriptionUrl)) {
            var searchConfig = new SearchConfiguration() {
                SearchTerm = SearchTerm,
                Version = Version,
            };
            var logger = LoggerFactory.CreateLogger<KiotaSearcher>();
            SearchResults = await new KiotaSearcher(logger, searchConfig).SearchAsync(ComponentDetached);
            DescriptionUrl = SearchResults.First().Value.DescriptionUrl.ToString();
        }
        var generationConfiguration = new GenerationConfiguration{
            OpenAPIFilePath = DescriptionUrl,
            IncludePatterns = IncludePatterns?.Split('\n', StringSplitOptions.RemoveEmptyEntries).Select(static x => x.Trim()).ToHashSet(),
            ExcludePatterns = ExcludePatterns?.Split('\n', StringSplitOptions.RemoveEmptyEntries).Select(static x => x.Trim()).ToHashSet(),
        };
        var builderLogger = LoggerFactory.CreateLogger<KiotaBuilder>();
        var urlTreeNode = await new KiotaBuilder(builderLogger, generationConfiguration).GetUrlTreeNodeAsync(ComponentDetached);

        var builder = new StringBuilder();
        RenderNode(urlTreeNode, 5, builder);
        Tree = builder.ToString();
    }
    private const string Cross = " ├─";
    private const string Corner = " └─";
    private const string Vertical = " │ ";
    private const string Space = "   ";
    private static void RenderNode(Microsoft.OpenApi.Services.OpenApiUrlTreeNode node, uint maxDepth, StringBuilder builder, string indent = "", int nodeDepth = 0)
    {
        builder.AppendLine(node.Segment);

        var children = node.Children;
        var numberOfChildren = children.Count;
        for (var i = 0; i < numberOfChildren; i++)
        {
            var child = children.ElementAt(i);
            var isLast = i == (numberOfChildren - 1);
            RenderChildNode(child.Value, maxDepth, builder, indent, isLast, nodeDepth);
        }
    }

    private static void RenderChildNode(Microsoft.OpenApi.Services.OpenApiUrlTreeNode node, uint maxDepth, StringBuilder builder, string indent, bool isLast, int nodeDepth = 0)
    {
        if (nodeDepth >= maxDepth && maxDepth != 0)
            return;
        builder.Append(indent);

        if (isLast)
        {
            builder.Append(Corner);
            indent += Space;
        }
        else
        {
            builder.Append(Cross);
            indent += Vertical;
        }

        RenderNode(node, maxDepth, builder, indent, nodeDepth + 1);
    }
}
