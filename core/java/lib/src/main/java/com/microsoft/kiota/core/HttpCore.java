/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.microsoft.kiota.core;

import java.io.IOException;
import java.lang.UnsupportedOperationException;
import java.util.Map;
import java.util.Objects;
import java.util.StringJoiner;
import java.util.concurrent.CompletableFuture;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import com.microsoft.kiota.RequestInfo;
import com.microsoft.kiota.ResponseHandler;
import com.microsoft.kiota.AuthenticationProvider;
import com.microsoft.kiota.core.serialization.JsonParseNode;
import com.microsoft.kiota.serialization.Parsable;

import okhttp3.MediaType;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.ResponseBody;
import okio.BufferedSink;

public class HttpCore implements com.microsoft.kiota.HttpCore {
    private final static String authorizationHeaderKey = "Authorization";
    private final static String contentTypeHeaderKey = "Content-Type";
    private final OkHttpClient client;
    private final AuthenticationProvider authProvider;
    public HttpCore(@Nonnull final AuthenticationProvider authenticationProvider){
        this(authenticationProvider, null);
    }
    public HttpCore(@Nonnull final AuthenticationProvider authenticationProvider, @Nullable final OkHttpClient client) {
        this.authProvider = Objects.requireNonNull(authenticationProvider, "parameter authenticationProvider cannot be null");
        if(client == null) {
            this.client = new OkHttpClient.Builder().build();
        } else {
            this.client = client;
        }
    }
    @Override
    @Nonnull
    public <ModelType extends Parsable> CompletableFuture<ModelType> sendAsync(@Nonnull final RequestInfo requestInfo, @Nonnull final Class<ModelType> targetClass, @Nullable final ResponseHandler responseHandler) {
        Objects.requireNonNull(requestInfo, "parameter requestInfo cannot be null");

        CompletableFuture<Void> tokenFuture;

        if(!requestInfo.headers.keySet().contains(authorizationHeaderKey)) {
            tokenFuture = this.authProvider
                .getAuthorizationToken(requestInfo.uri)
                .thenApply(token -> {
                    if(token == null || token.isEmpty()) {
                        throw new UnsupportedOperationException("Could not get an authorization token", null);
                    }
                    requestInfo.headers.put(authorizationHeaderKey, "Bearer " + token);
                    return null;
                });
        } else {
            tokenFuture = CompletableFuture.completedFuture(null);
        }
        return tokenFuture.thenCompose(x -> {
            final HttpCoreCallbackFutureWrapper wrapper = new HttpCoreCallbackFutureWrapper();
            this.client.newCall(getRequestFromRequestInfo(requestInfo)).enqueue(wrapper);
            return wrapper.future;
        }).thenCompose(response -> {
            if(responseHandler == null) {
                final ResponseBody body = response.body();
                try {
                    final String rawJson = body.string();
                    final JsonParseNode rootNode = new JsonParseNode(rawJson);
                    final ModelType result = rootNode.getObjectValue(targetClass);
                    return CompletableFuture.completedStage(result);
                } catch(IOException ex) {
                    return CompletableFuture.failedFuture(new RuntimeException("failed to read the response body", ex));
                } finally {
                    response.close();
                }
            } else {
                return responseHandler.handleResponseAsync(response);
            }
        });
    }
    private Request getRequestFromRequestInfo(@Nonnull final RequestInfo requestInfo) {
        final StringBuilder urlBuilder = new StringBuilder(requestInfo.uri.toString());

        if(!requestInfo.queryParameters.isEmpty()) {
            urlBuilder.append('?');
            final StringJoiner qParamsJoiner = new StringJoiner("&");
            for (final Map.Entry<String, Object> qPram : requestInfo.queryParameters.entrySet()) {
                final Object value = qPram.getValue();
                final String valueStr = value == null ? "" : value.toString();
                qParamsJoiner.add(qPram.getKey() + (valueStr.isEmpty() ? "" : "=") + valueStr);
            }
            urlBuilder.append(qParamsJoiner.toString());
        }
        final RequestBody body = requestInfo.content == null ? null :
                                new RequestBody() {
                                    @Override
                                    public MediaType contentType() {
                                        final String contentType = requestInfo.headers.containsKey(contentTypeHeaderKey) ? requestInfo.headers.get(contentTypeHeaderKey) : "";
                                        if(contentType.isEmpty()) {
                                            return null;
                                        } else {
                                            return MediaType.parse(contentType);
                                        }
                                    }

                                    @Override
                                    public void writeTo(BufferedSink sink) throws IOException {
                                        sink.write(requestInfo.content.readAllBytes());
                                        //TODO this is dirty and is probably going to use a lot of memory for large payloads, loop on a buffer instead
                                    }

                                };
        final Request.Builder requestBuilder = new Request.Builder()
                                            .url(urlBuilder.toString())
                                            .method(requestInfo.httpMethod.toString(), body);
        for (final Map.Entry<String,String> header : requestInfo.headers.entrySet()) {
            requestBuilder.addHeader(header.getKey(), header.getValue());
        }
        return requestBuilder.build();
    }
}
